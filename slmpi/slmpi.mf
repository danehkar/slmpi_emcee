# This file was auto-generated by SLIRP version pre2.0.0-31, using the command:
#
#     '/lecanard.real/adanehka/isis/bin/slirp' '-make' 'slmpi.h' 'slmpi.o' 


MODNAME = slmpi
SELF =  -f slmpi.mf
GLUE_FILE_EXT = .c
LINK = $(C_LINK)
SL_SCRIPTS = 
LFLAGS = 
IFLAGS =  -I.
SRC =  slmpi.h

OBJ = slmpi_glue.o slmpi.o
SLIRP = slsh -n /lecanard.real/adanehka/isis/bin/slirp -m slmpi
STUBS = 

############################################################################
#
# Makefile auto-generated by SLIRP, the (Sl)ang (I)nte(r)face (P)ackage
#
# Copyright (C) 2003-2008 Massachusetts Institute of Technology
# Copyright (C) 2002 Michael S. Noble <mnoble@space.mit.edu>
#
# This file should be reviewed, to verify the macros defined above:
#
#  MODNAME	  name of the wrapper module being generated
#  GLUE_FILE_EXT  .c, .cc, etc file extension of the generated glue code
#  LFLAGS	  flags for/paths to wrapped libs/objects and dependencies
#  LDFLAGS        Linker flags
#  IFLAGS	  -I paths to input files for wrapped objs/libs
#  OMPFLAGS	  OpenMP compile/link flags to use (may be empty)
#  SRC		  names of input specified at slirp invocation (e.g. .h files)
#  OBJ		  object code to link into the module
#  SLIRP	  path to & flags for SLIRP command which generated this
#  SL_SCRIPTS	  The names of any .sl files used by/with your module, which
#		  ensures they are installed by 'make install' (below).
#
#  This file aims at being only a starting point for module generation.  In
#  general it should not be used verbatim for distribution/production code.
#
############################################################################

SHELL   = /bin/sh
RM	= \rm -f
RM_R    = \rm -rf

#---------------------------------------------------------------------------
# Module definitions
#---------------------------------------------------------------------------

SH_EXT		= .so
MODULE          = $(MODNAME)-module$(SH_EXT)
GLUE            = $(MODNAME)_glue
GLUE_SRC        = $(GLUE)$(GLUE_FILE_EXT)
TEST_SCRIPT	= $(MODNAME)-test.sl
TEST_APP	= slsh -n
SET_SECURITY	= /usr/bin/chcon -t texrel_shlib_t $(MODULE) || true

all: $(MODULE)

#---------------------------------------------------------------------------
# Section: S-Lang and related header/library macros
#---------------------------------------------------------------------------

prefix		= /home/adanehka/disk2/isis
exec_prefix	= ${prefix}
datarootdir	= ${prefix}/share
SLANGINC	= -I/home/adanehka/disk2/isis/include
SLANGLIB	= -Wl,-R/home/adanehka/disk2/isis/lib -L/home/adanehka/disk2/isis/lib -lslang
DL_LIB		= -ldl
MODULE_INSTALL_DIR = ${exec_prefix}/lib/slang/v2/modules
SCRIPTS_INSTALL_DIR = ${datarootdir}/slsh/local-packages

#---------------------------------------------------------------------------
# Section: Compilers, libraries, and shared object names & versions
#---------------------------------------------------------------------------

SO		= $(MODULE)
SO_MAJOR_VER	= 1
SO_MINOR_VER	= 0.0
SO_MAJOR_NAME	= $(SO).$(SO_MAJOR_VER)
LDFLAGS		= 

CC		= /usr/lib64/openmpi/bin/mpicc
CFLAGS		= -g -O2
SO_CFLAGS	= $(CFLAGS) -fPIC -I. $(SLANGINC) $(IFLAGS) $(OMPFLAGS)
SO_LINK_FLAGS	= $(OMPFLAGS) $(LDFLAGS) -shared -Wl,-soname,$(SO_MAJOR_NAME)
C_COMPILE	= $(CC) $(SO_CFLAGS) -c
C_LINK		= $(CC) $(SO_LINK_FLAGS)

CXX		= /usr/bin/g++
CXX_COMPILE	= $(CXX) $(SO_CFLAGS) -c
CXX_LINK	= $(CXX) $(SO_LINK_FLAGS)

FC              = /usr/bin/gfortran
FCFLAGS		= -g -O2 -fPIC
FCLIBS          = -Wl,-R/usr/lib/gcc/x86_64-redhat-linux/4.4.7:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64:/lib/../lib64:/usr/lib/../lib64:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../..  -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7 -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../.. -lgfortranbegin -lgfortran -lm
FORTRAN_COMPILE = $(FC) $(FCFLAGS) -c
FORTRAN_LINK    = $(FC) $(LDFLAGS)

.PHONY: all clean test
.SUFFIXES: .cc .cxx

$(MODULE): $(OBJ)
	@echo
	$(LINK) -o $@ $(OBJ) $(LFLAGS) $(SLANGLIB) \
	   					$(DL_LIB) -lm $(MISC_LIBS)
	-$(SET_SECURITY)
	@echo
	@echo "Type '$(MAKE) $(SELF) test' to nominally verify $(MODULE)."

.c.o:
	@echo
	$(C_COMPILE) $?

.cc.o:
	@echo
	$(CXX_COMPILE) $?

.cxx.o:
	@echo
	$(CXX_COMPILE) $?

.f.o:
	@echo
	$(FORTRAN_COMPILE) $?

$(GLUE_SRC): $(STUBS) #slirprc
	@echo
	@echo Generating glue code ...
	@echo
	$(SLIRP) $(IFLAGS) $(SRC)
	@echo

$(STUBS):
	@echo
	@echo Generating stubs ...
	@echo
	$(SLIRP) $(IFLAGS) -stubs $(SRC)

clean:
	-$(RM) $(MODULE) *~ *.o $(GLUE_SRC) $(TEST_SCRIPT) sfwrap_*.o $(STUBS)

test: $(MODULE) $(TEST_SCRIPT)
	$(TEST_APP) $(TEST_SCRIPT)
	@if [ $$? -eq 0 ] ; then \
	   echo "Success!" ; \
	 else \
	   echo ; \
	   echo "Try adding more libraries or .o files to the LFLAGS";\
	   echo "or OBJ macro definitions within this makefile." ; \
	fi

$(TEST_SCRIPT):
	@echo "set_import_module_path( strcat(\".\", char(path_get_delimiter()), get_import_module_path()) );" > $(TEST_SCRIPT)
	@echo 'import("$(MODNAME)");' >> $(TEST_SCRIPT)
	@echo 'exit(0);' >> $(TEST_SCRIPT)

#---------------------------------------------------------------------------
# Section: module installation
#---------------------------------------------------------------------------

DESTDIR =
DEST_MODULE_INSTALL_DIR = $(DESTDIR)$(MODULE_INSTALL_DIR)
DEST_SCRIPTS_INSTALL_DIR = $(DESTDIR)$(SCRIPTS_INSTALL_DIR)

install: $(MODULE)
	$(MAKE) MKINSDIR INSDIR=$(DEST_MODULE_INSTALL_DIR)
	cp $(MODULE) $(DEST_MODULE_INSTALL_DIR)
	chmod 644 $(DEST_MODULE_INSTALL_DIR)/$(MODULE) 
	if test -n "$(SL_SCRIPTS)" ; then \
	   $(MAKE) -e MKINSDIR INSDIR=$(DEST_SCRIPTS_INSTALL_DIR) ; \
	fi
	for F in $(SL_SCRIPTS) ; do \
	   echo cp $$F $(DEST_SCRIPTS_INSTALL_DIR) ; \
	   cp $$F $(DEST_SCRIPTS_INSTALL_DIR) ; \
	   if [ $$? -ne 0 ] ; then false; fi ; \
	   chmod 444 $(DEST_SCRIPTS_INSTALL_DIR)/$$F ; \
	   if [ $$? -ne 0 ] ; then false; fi ; \
	done

uninstall: $(MODULE)
	-$(RM) $(DEST_MODULE_INSTALL_DIR)/$(MODULE)
	for F in $(SL_SCRIPTS) ; do \
	   $(RM) -f $(DEST_SCRIPTS_INSTALL_DIR)/$$F ; \
	done

# Adapted from mkinsdir.sh (Noah Friedman <friedman@prep.ai.mit.edu>)
MKINSDIR:
	@errstatus=0 ; \
	set `echo ":$(INSDIR)" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'` ; \
	pathcomp= ; \
	for d in $$@ ; do \
	   pathcomp="$$pathcomp$$d" ; \
	   case "$$pathcomp" in \
	      -* ) pathcomp=./$$pathcomp ;; \
	   esac ; \
	   if test ! -d "$$pathcomp"; then \
		echo "mkdir $$pathcomp" 1>&2 ; \
		mkdir "$$pathcomp" || errstatus=$$? ; \
	   fi ; \
	   pathcomp="$$pathcomp/" ; \
	done
